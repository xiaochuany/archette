"""implements the class GARCHETTE: zero mean GARCH(1,1) model with t noise distribution"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['GARCHETTE']

# %% ../nbs/00_core.ipynb 3
from functools import cached_property
from typing import Literal
import numpy as np
from numba import njit
from arch import arch_model

# %% ../nbs/00_core.ipynb 4
@njit
def _get_vs(y, params, sig2_init=1.0):
    """
    not clear how arch package initialize the conditional variance at time 0
    here kick off the computation with value 1.0
    it is provably true that vs computed below
    is insensitive to the initial value (coupling exponentially fast)
    """
    om,al,be = params
    vs = np.full(y.size, sig2_init)
    for i in range(1,y.size):
        vs[i] = om + al * y[i-1]**2 + be * vs[i-1]
    return vs

@njit
def _make_fcst_vs(params,last_v, last_y, horizon):
    om,al,be = params
    fcst_vs = np.empty(horizon)
    fcst_vs[0] = om + al* last_y**2 + be* last_v
    for i in range(1,horizon):
        fcst_vs[i] = om + (al+be) * fcst_vs[i-1]
    return fcst_vs

@njit(fastmath=True)
def _simulate(params, last_y, last_v, horizon, n_rep, seed, ws=None):
    om,al,be = params
    if ws is None:
        np.random.seed(seed)
        ws = np.random.randn(n_rep,horizon)
    y = np.empty((n_rep, horizon+1))
    v = np.empty((n_rep, horizon+1))
    y[:,0] = last_y
    v[:,0] = last_v
    for i in range(1,horizon+1):
        v[:,i] = om + al* y[:,i-1]**2 + be * v[:,i-1]
        y[:,i] = np.sqrt(v[:,i]) * ws[:,i-1]
        # used fastmath for sqrt; but not sure if this makes a difference
    return y[:,1:]

# @jitclass
class GARCHETTE:
    """simple garch"""
    def __init__(self):
        self._y = None
        self.params = None
        self._is_fit = False
        self._v_init = 1.0

    def fit(self,y):
        self._y = y
        res = arch_model(y, mean="Zero", dist="t", rescale=False).fit(disp="off")
        om,al,be,nu = res.params
        self.params = np.array((om,al,be))
        self._v_init = res.conditional_volatility[0]**2  ## feed the initial value of arch_model impl to be coherent
        self._is_fit = True
        return self

    @cached_property
    def vs(self):
        assert self._is_fit
        return _get_vs(self._y, self.params, sig2_init = self._v_init)

    @cached_property
    def std_resids(self):
        assert self._is_fit
        return self._y / np.sqrt(self.vs)

    def forecast_vs(self, horizon):
        assert self._is_fit
        return _make_fcst_vs(self.params, self.vs[-1], self._y[-1], horizon)

    def simulate(self, horizon, method:Literal["bootstrap","simulate"]="simulate", n_rep=1_000, seed=42):
        assert self._is_fit
        if method == "bootstrap":
            np.random.seed(seed)
            ws = np.random.choice(self.std_resids, size=(n_rep, horizon),replace=True)
        else: ws=None
        return _simulate(self.params,self._y[-1], self.vs[-1], horizon, n_rep, seed, ws)
