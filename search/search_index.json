{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"archette","text":"<p>Let's build arch-like models from scratch. </p> <p>This includes model specification, maximum likelihood estimation, etc. </p> <p>The current implementation is to use <code>numpy</code> for array manipulations, <code>scipy</code> for optimization of objectives,  and <code>numba</code> for acceleration. </p> <p>TODO: reduce dependency to  <code>jax</code> alone, with optimization done by hand (gradient descent and the likes) in place of the high level API of <code>scipy.optimize</code>.   </p>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#archette.garch.GARCH","title":"archette.garch.GARCH","text":"<pre><code>GARCH()\n</code></pre> <p>GARCH(1,1) model</p> Source code in <code>archette/garch.py</code> <pre><code>def __init__(self):\n    self._y = None\n    self.params = None  # [omega, alpha, beta]\n    self._is_fit = False\n    self._v_init = None\n</code></pre>"},{"location":"#archette.garch.GARCH.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params = None\n</code></pre>"},{"location":"#archette.garch.GARCH.vs","title":"vs  <code>cached</code> <code>property</code>","text":"<pre><code>vs\n</code></pre> <p>conditional variance based on the fit parameters. Must call the fit method first before accessing this property</p> RETURNS DESCRIPTION <code>ndarray</code> <p>estimated conditional variance at each time point</p>"},{"location":"#archette.garch.GARCH.std_resids","title":"std_resids  <code>cached</code> <code>property</code>","text":"<pre><code>std_resids\n</code></pre> <p>standardized residual based on the fit parameters. Must call the fit method first before accessing this property</p> RETURNS DESCRIPTION <code>ndarray</code> <p>estimated standardized residual at each time point</p>"},{"location":"#archette.garch.GARCH.fit","title":"fit","text":"<pre><code>fit(y)\n</code></pre> <p>fit a GARCH(1,1) model with MLE (assuming Gaussian noise)</p> PARAMETER DESCRIPTION <code>y</code> <p>observed time series</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>GARCH</code> <p>self</p> Source code in <code>archette/garch.py</code> <pre><code>def fit(self, y: np.ndarray) -&gt; \"GARCH\":\n    \"\"\"fit a GARCH(1,1) model with MLE (assuming Gaussian noise)\n\n    Parameters:\n        y: observed time series\n\n    Returns:\n        self\n    \"\"\"\n    self._y = y\n    self._v_init = (\n        y.var()\n    )  # != arch_model(y).fit().conditional_volatility[0]**2 but close\n    func = self.nll\n    self.params = minimize(\n        func,\n        x0=(self._v_init * 0.4, 0.3, 0.3),\n        bounds=[(0, None), (0, None), (0, None)],\n        constraints={\"type\": \"ineq\", \"fun\": lambda x: 1 - x[1] - x[2]},\n    ).x\n    self._is_fit = True\n    return self\n</code></pre>"},{"location":"#archette.garch.GARCH.nll","title":"nll","text":"<pre><code>nll(params)\n</code></pre> <p>negative log likelihood of the series at the given params</p> PARAMETER DESCRIPTION <code>params</code> <p>[omega, alpha, beta]</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>float</code> <p>negative log likelihood</p> Source code in <code>archette/garch.py</code> <pre><code>def nll(self, params: np.ndarray) -&gt; float:\n    \"\"\"negative log likelihood of the series at the given params\n\n    Parameters:\n        params: [omega, alpha, beta]\n\n    Returns:\n        negative log likelihood\n    \"\"\"\n    return _nllgauss(self._y, params, self._v_init)\n</code></pre>"},{"location":"#archette.garch.GARCH.forecast_vs","title":"forecast_vs","text":"<pre><code>forecast_vs(horizon)\n</code></pre> <p>forecast conditional variance in the horizon (future)</p> PARAMETER DESCRIPTION <code>horizon</code> <p>forecast horizon</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>forecasted conditional variance</p> Source code in <code>archette/garch.py</code> <pre><code>def forecast_vs(self, horizon: int) -&gt; np.ndarray:\n    \"\"\"forecast conditional variance in the horizon (future)\n\n    Parameters:\n        horizon: forecast horizon\n\n    Returns:\n        forecasted conditional variance\n    \"\"\"\n    assert self._is_fit\n    return _make_fcst_vs(self.params, self.vs[-1], self._y[-1], horizon)\n</code></pre>"},{"location":"#archette.garch.GARCH.simulate","title":"simulate","text":"<pre><code>simulate(horizon, method='simulate', n_rep=1000, seed=42)\n</code></pre> <p>simulate paths from the fitted model</p> PARAMETER DESCRIPTION <code>horizon</code> <p>path length</p> <p> TYPE: <code>int</code> </p> <code>method</code> <p>\"bootstrap\" or \"simulate\" (generate new noise)</p> <p> TYPE: <code>Literal['bootstrap', 'simulate']</code> DEFAULT: <code>'simulate'</code> </p> <code>n_rep</code> <p>number of repetitions</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>seed</code> <p>random seed</p> <p> TYPE: <code>int</code> DEFAULT: <code>42</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>simulated paths</p> Source code in <code>archette/garch.py</code> <pre><code>def simulate(\n    self,\n    horizon: int,\n    method: Literal[\"bootstrap\", \"simulate\"] = \"simulate\",\n    n_rep: int = 1_000,\n    seed: int = 42,\n) -&gt; np.ndarray:\n    \"\"\"simulate paths from the fitted model\n\n\n    Parameters:\n        horizon: path length\n        method: \"bootstrap\" or \"simulate\" (generate new noise)\n        n_rep: number of repetitions\n        seed: random seed\n\n    Returns:\n        simulated paths\n    \"\"\"\n    assert self._is_fit\n    if method == \"bootstrap\":\n        np.random.seed(seed)\n        ws = np.random.choice(self.std_resids, size=(n_rep, horizon), replace=True)\n    else:\n        ws = None\n    return _simulate(\n        self.params, self._y[-1], self.vs[-1], horizon, n_rep, seed, ws\n    )\n</code></pre>"}]}